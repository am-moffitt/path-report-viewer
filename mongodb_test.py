import os
import json
import pymongo
from pymongo import MongoClient
from bson.objectid import ObjectId
from groq import Groq
import streamlit as st
import pandas as pd
from io import StringIO
import uuid
import time

# -------------------------------------------------------------------
# Configuration and Setup
# -------------------------------------------------------------------

os.environ['GROQ_API_KEY'] = 'add api key here'

# Verify that the GROQ_API_KEY is set; if not, display an error and stop the application.
if 'GROQ_API_KEY' not in os.environ or not os.environ['GROQ_API_KEY']:
    st.error("Error: GROQ_API_KEY is not set in environment variables.")
    st.stop()

# MongoDB configuration settings.
# Update these variables if your MongoDB setup differs.
MONGO_URI = "mongodb://localhost:27017/"
DATABASE_NAME = "clinical_data"
COLLECTION_NAME = "medical_data"

# -------------------------------------------------------------------
# System Prompts for LLM
# -------------------------------------------------------------------

# System prompt for data extraction.
# This prompt instructs the LLM to act as a pathologist extracting specific information from a pathology report.
system_prompt_extraction = '''
You are a pathologist who has received a pathology report for a patient. This report has been generated by using OCR on a scanned document, so it may contain errors. Your task is to extract information from the report and provide a brief explanation for each choice.
Carefully analyze the following pathology report and extract information for each category. If information is unclear or not present, choose "UNKNOWN". Provide a brief, evidence-based explanation for each choice by quoting the report directly.

For each category, provide:
[Category]: [Chosen option]
Explanation: [Brief explanation with direct quotes from the report]

Output the data in JSON format as follows:
{
  "mrn": "<string>",
  "site": "<string>",
  "site_score": <number>,
  "stage": "<string>",
  "stage_score": <number>,
  "laterality": "<string>",
  "laterality_score": <number>,
  "grade": "<string>",
  "grade_score": <number>,
  "histology": "<string>",
  "histology_score": <number>,
  "behaviour": "<string>",
  "behaviour_score": <number>
}

Example:
Pathology Report: "BREAST, NEEDLE LOCALIZED LUMPECTOMY: Invasive ductal carcinoma, high grade. Tumor measures 2.5 cm. Left breast specimen."

Site: "BREAST"
Explanation: "The report states 'BREAST, NEEDLE LOCALIZED LUMPECTOMY'."

Stage: "pT2N0M0"
Explanation: "The report states 'Tumor measures 2.5 cm', which corresponds to pT2. No lymph node involvement is mentioned, so pN0 is assumed. Therefore, the stage is pT2N0M0."

Laterality: "LEFT"
Explanation: "The report specifies 'Left breast specimen'."

Grade: "high grade"
Explanation: "The report mentions 'high grade'."

Histology: "Invasive ductal carcinoma"
Explanation: "The report states 'Invasive ductal carcinoma'."

Behaviour: "UNKNOWN"
Explanation: "The report does not mention the behavior of the tumor."
'''

# System prompt for data evaluation.
# This prompt instructs the LLM to evaluate the accuracy of the extracted data against the ground truth.
system_prompt_evaluation = '''
You are tasked with reviewing and scoring the accuracy of information extracted from a pathology report. Your goal is to evaluate each category by comparing the AI's extraction with the actual content in the report. Assess whether the extracted values match the report's information, and provide a justification along with a score for each.

For each category, include:
- **AI Extraction**: [Extracted information from Stage 1]
- **Correct Value**: [Actual correct information from the report]
- **Justification**: [Evidence from the report supporting the correct value, with direct quotes]
- **Score**: [1 if correct, 0 if incorrect]
- **Reasoning**: [Explanation on why the extraction is correct or incorrect]

Output a JSON evaluation with fields:
{
  "mrn_evaluation": {"extracted": "<extracted_mrn>", "correct": "<ground_truth_mrn>", "score": <number>, "justification": "<reasoning>"},
  "site_evaluation": {"extracted": "<extracted_site>", "correct": "<ground_truth_site>", "score": <number>, "justification": "<reasoning>"},
  "stage_evaluation": {"extracted": "<extracted_stage>", "correct": "<ground_truth_stage>", "score": <number>, "justification": "<reasoning>"},
  "laterality_evaluation": {"extracted": "<extracted_laterality>", "correct": "<ground_truth_laterality>", "score": <number>, "justification": "<reasoning>"},
  "grade_evaluation": {"extracted": "<extracted_grade>", "correct": "<ground_truth_grade>", "score": <number>, "justification": "<reasoning>"},
  "histology_evaluation": {"extracted": "<extracted_histology>", "correct": "<ground_truth_histology>", "score": <number>, "justification": "<reasoning>"},
  "behaviour_evaluation": {"extracted": "<extracted_behaviour>", "correct": "<ground_truth_behaviour>", "score": <number>, "justification": "<reasoning>"}
}

Example:
**Pathology Report**:  
"BREAST, UPPER INNER QUADRANT, NEEDLE LOCALIZED LUMPECTOMY: Invasive ductal carcinoma, high grade. Tumor measures 2.5 cm. Left breast specimen."

**Categories**:
1. **Site**:  
   - **AI Extraction**: "UPPER INNER QUADRANT"  
   - **Correct Value**: "UPPER INNER QUADRANT"  
   - **Justification**: The report explicitly states "UPPER INNER QUADRANT"  
   - **Score**: 1  
   - **Reasoning**: The extraction directly matches the report.

2. **Stage**:  
   - **AI Extraction**: "pT2N0M0"  
   - **Correct Value**: "pT2N0M0"  
   - **Justification**: Tumor measures 2.5 cm (pT2), no lymph node involvement mentioned  
   - **Score**: 1  
   - **Reasoning**: The extraction is correct based on the size criteria.

3. **Laterality**:  
   - **AI Extraction**: "LEFT"  
   - **Correct Value**: "LEFT"  
   - **Justification**: Report states "Left breast specimen"  
   - **Score**: 1  
   - **Reasoning**: The extraction matches the report exactly.
'''

# -------------------------------------------------------------------
# User Prompt Templates
# -------------------------------------------------------------------

# User prompt template for data extraction.
# This template is used to format the user's clinical note for the LLM to extract specific fields.
user_prompt_template_extraction = '''
Use information from the following clinical note to extract:
- mrn (medical record number)
- site (be as specific as possible, include quadrant if available)
- stage (if mentioned, this might be a number, a Roman numeral, or a phrase)
- laterality
- grade (if mentioned, might be G1/G2/G3 or descriptive)
- histology (type of cancer/tumor)
- behaviour (if mentioned)
If a field is not present please mark it as "UNKNOWN"

Clinical Note:
{clinical_note}
'''

# User prompt template for data evaluation.
# This template is used to format the extracted data and ground truth for the LLM to evaluate accuracy.
user_prompt_template_evaluation = '''
Given the extracted data and the known ground truth, evaluate the correctness of each field. Be strict and precise in your evaluation.

Extracted Data:
{extracted_json}

Ground Truth:
{ground_truth_json}
'''

# -------------------------------------------------------------------
# Helper Functions for LLM Communication
# -------------------------------------------------------------------

def call_llm(messages, model="mixtral-8x7b-32768"):
    """
    Sends a request to the Groq API to perform a chat completion.

    Parameters:
    - messages (list): A list of message dictionaries with 'role' and 'content' keys.
    - model (str): The model to use for the completion. Default is "mixtral-8x7b-32768".

    Returns:
    - dict or None: The JSON response from the API if successful, otherwise None.
    """
    client = Groq(api_key=os.getenv('GROQ_API_KEY'))
    try:
        chat_completion = client.chat.completions.create(
            messages=messages,
            model=model,
            response_format={"type": "json_object"}
        )
        return json.loads(chat_completion.choices[0].message.content)
    except Exception as e:
        st.error(f"Error during Groq API call: {e}")
        return None

def extract_medical_data(clinical_note):
    """
    Extracts medical data from a given clinical note using the LLM.

    Parameters:
    - clinical_note (str): The clinical note text from which to extract data.

    Returns:
    - dict or None: A dictionary containing the extracted medical data, or None if extraction fails.
    """
    messages = [
        {"role": "system", "content": system_prompt_extraction},
        {"role": "user", "content": user_prompt_template_extraction.format(clinical_note=clinical_note)}
    ]
    return call_llm(messages)

def evaluate_medical_data(extracted_data, ground_truth_data):
    """
    Evaluates the extracted medical data against the ground truth using the LLM.

    Parameters:
    - extracted_data (dict): The data extracted by the AI.
    - ground_truth_data (dict): The actual correct data for comparison.

    Returns:
    - dict or None: A dictionary containing evaluation results for each field, or None if evaluation fails.
    """
    messages = [
        {"role": "system", "content": system_prompt_evaluation},
        {"role": "user", "content": user_prompt_template_evaluation.format(
            extracted_json=json.dumps(extracted_data, indent=2),
            ground_truth_json=json.dumps(ground_truth_data, indent=2)
        )}
    ]
    return call_llm(messages)

# -------------------------------------------------------------------
# Data Validation and Storage Functions
# -------------------------------------------------------------------

def is_valid_record(record):
    """
    Determines if a given record contains valid data.

    A record is considered valid if at least one of the key fields (site, stage, laterality, grade)
    does not have a value of "N/A" or "UNKNOWN".

    Parameters:
    - record (dict): The medical record to validate.

    Returns:
    - bool: True if the record contains valid data, False otherwise.
    """
    try:
        stage_3_data = json.loads(record.get('stage_3_output', '{}'))
    except json.JSONDecodeError:
        stage_3_data = {}
    
    # Define key fields to check for validity
    key_fields = ['site', 'stage', 'laterality', 'grade']
    
    # Check if all key fields are either 'N/A', 'UNKNOWN', or missing
    all_na = all(
        stage_3_data.get(field, 'N/A') in ['N/A', 'UNKNOWN'] or 
        not stage_3_data.get(field)
        for field in key_fields
    )
    
    return not all_na

def store_medical_data_in_mongodb(data):
    """
    Stores a medical record in MongoDB if it contains valid information.

    Utilizes the `update_one` method with `upsert=True` to insert the record if it doesn't exist,
    or update it if it does.

    Parameters:
    - data (dict): The medical data to store.

    Returns:
    - str or None: The string representation of the record's ID if stored successfully, None otherwise.
    """
    try:
        # Validate the record first
        if not is_valid_record(data):
            st.warning(f"Skipping record {data.get('_id')} - insufficient data (all N/A or UNKNOWN)")
            return None
            
        # Establish a connection to MongoDB
        client = MongoClient(MONGO_URI)
        db = client[DATABASE_NAME]
        collection = db[COLLECTION_NAME]
        
        # Use update_one with upsert=True to insert or update the record based on _id
        result = collection.update_one(
            {"_id": data.get("_id")},  # Query by _id
            {"$set": data},            # Update with the entire data
            upsert=True                # Insert if not found
        )
        return str(data.get("_id"))
    except Exception as e:
        st.error(f"Error inserting data into MongoDB: {e}")
        return None

def store_batch_in_mongodb():
    """
    Stores all processed synthetic data in MongoDB with proper formatting for all stages.

    Iterates through the synthetic clinical notes, processes each one, and stores it in the database
    if it contains valid information.

    Returns:
    - bool: True if the batch storage is successful, False otherwise.
    """
    try:
        if not (hasattr(st.session_state, 'all_extracted_data') and 
                hasattr(st.session_state, 'all_evaluation_data')):
            st.error("No processed data available to store")
            return False

        stored_count = 0
        skipped_count = 0
        for i, (note, extracted, evaluated) in enumerate(zip(
            synthetic_clinical_notes,
            st.session_state.all_extracted_data,
            st.session_state.all_evaluation_data
        )):
            # Generate a unique ID for each record
            record_id = str(uuid.uuid4())
            
            # Create the complete record with proper formatting
            record = {
                "_id": record_id,
                "pdf_file_name": f"synthetic_example_{i+1}.pdf",
                "organ": "BREAST",  # Default for synthetic examples
                "text": note['clinical_note'],  # Changed from clinical_note to text
                "stage_1_output": format_stage_1_output(extracted),
                "stage_2_output": format_stage_2_output(evaluated),
                "stage_3_output": format_stage_3_output(extracted)
            }
            
            # Only store if the record is valid
            if is_valid_record(record):
                try:
                    client = MongoClient(MONGO_URI)
                    db = client[DATABASE_NAME]
                    collection = db[COLLECTION_NAME]
                    
                    result = collection.update_one(
                        {"_id": record_id},
                        {"$set": record},
                        upsert=True
                    )
                    
                    if result.modified_count > 0 or result.upserted_id:
                        stored_count += 1
                        
                except Exception as e:
                    st.error(f"Error storing record {i+1}: {str(e)}")
                    continue
            else:
                skipped_count += 1
                st.warning(f"Skipping record {record_id} - insufficient data (all N/A or UNKNOWN)")
                
        if stored_count > 0:
            st.success(f"Successfully stored {stored_count} record(s) in MongoDB")
        if skipped_count > 0:
            st.info(f"Skipped {skipped_count} record(s) with insufficient data")
        return True
                
    except Exception as e:
        st.error(f"Error in batch storage process: {str(e)}")
        return False

def clear_invalid_records():
    """
    Removes all records from MongoDB that contain only 'N/A' or 'UNKNOWN' values in key fields.

    Iterates through all records in the collection and deletes those that do not contain valid data.

    Returns:
    - int: The number of records removed.
    """
    try:
        client = MongoClient(MONGO_URI)
        db = client[DATABASE_NAME]
        collection = db[COLLECTION_NAME]
        
        all_records = list(collection.find({}))
        removed_count = 0
        
        for record in all_records:
            if not is_valid_record(record):
                collection.delete_one({"_id": record["_id"]})
                removed_count += 1
        
        return removed_count
    except Exception as e:
        st.error(f"Error clearing invalid records: {e}")
        return 0

def delete_all_records_from_mongodb():
    """
    Deletes all records from the specified MongoDB collection.

    Returns:
    - int: The number of records deleted.
    """
    try:
        client = MongoClient(MONGO_URI)
        db = client[DATABASE_NAME]
        collection = db[COLLECTION_NAME]
        result = collection.delete_many({})
        return result.deleted_count
    except Exception as e:
        st.error(f"Error deleting records from MongoDB: {e}")
        return 0

# -------------------------------------------------------------------
# Data Processing Functions
# -------------------------------------------------------------------

def process_clinical_notes(notes):
    """
    Processes a list of clinical notes by extracting and evaluating medical data.

    For each clinical note, performs data extraction and evaluation, then stores the valid records
    in the database.

    Parameters:
    - notes (list): A list of dictionaries, each containing a 'clinical_note' and 'ground_truth'.

    Returns:
    - list: A list of processed and stored records.
    """
    final_outputs = []
    skipped_count = 0
    
    for note in notes:
        # Generate a UUID for each record
        record_id = str(uuid.uuid4())
        
        # Extract data from the note
        extracted_data = extract_medical_data(note['clinical_note'])
        
        # Create the record with the new structure
        final_output = {
            "_id": record_id,
            "pdf_file_name": note.get('pdf_file_name', './Reports/UNKNOWN/pdfs/unknown.PDF'),
            "organ": note.get('organ', 'UNKNOWN'),
            "clinical_note": note['clinical_note'],
            "ground_truth": note['ground_truth'],
            "extracted_data": extracted_data,
            "evaluation": None,  # Will be populated later
            "stage_3_output": json.dumps({
                "site": extracted_data.get('site', 'N/A'),
                "stage": extracted_data.get('stage', 'N/A'),
                "laterality": extracted_data.get('laterality', 'N/A'),
                "grade": extracted_data.get('grade', 'N/A'),
                "site_score": extracted_data.get('site_score', 'N/A'),
                "stage_score": extracted_data.get('stage_score', 'N/A'),
                "laterality_score": extracted_data.get('laterality_score', 'N/A'),
                "grade_score": extracted_data.get('grade_score', 'N/A')
            })
        }
        
        # Only store and add to outputs if valid
        if is_valid_record(final_output):
            stored_id = store_medical_data_in_mongodb(final_output)
            if stored_id:
                final_outputs.append(final_output)
        else:
            skipped_count += 1
    
    if skipped_count > 0:
        st.info(f"Skipped {skipped_count} record(s) with insufficient data (all N/A or UNKNOWN)")
    
    return final_outputs

def process_all_synthetic_data():
    """
    Processes all synthetic data examples and stores results in Streamlit's session state.

    This function iterates through predefined synthetic clinical notes, extracts and evaluates data
    for each, and stores the results in the session state for further processing or display.

    Returns:
    - tuple: Two lists containing all extracted data and all evaluation data respectively.
    """
    final_outputs = []
    total_notes = len(synthetic_clinical_notes)
    progress_bar = st.progress(0)
    
    all_extracted_data = []
    all_evaluation_data = []
    
    for i, note in enumerate(synthetic_clinical_notes):
        st.write(f"Processing example {i+1}/{total_notes}...")
        
        # First API call - Extract data
        extracted_data = extract_medical_data(note['clinical_note'])
        if extracted_data:
            st.write(f"✓ Extraction completed for example {i+1}")
            # Second API call - Evaluate data
            evaluation_data = evaluate_medical_data(extracted_data, note['ground_truth'])
            if evaluation_data:
                st.write(f"✓ Evaluation completed for example {i+1}")
                all_extracted_data.append(extracted_data)
                all_evaluation_data.append(evaluation_data)
            else:
                all_extracted_data.append(extracted_data)
                all_evaluation_data.append(None)
                st.error(f"Failed to evaluate data for example {i+1}")
        else:
            all_extracted_data.append(None)
            all_evaluation_data.append(None)
            st.error(f"Failed to extract data for example {i+1}")
            
        # Update progress bar
        progress_bar.progress((i + 1) / total_notes)
        time.sleep(0.1)  # To visualize the progress
        
    # Store results in session state
    st.session_state.all_extracted_data = all_extracted_data
    st.session_state.all_evaluation_data = all_evaluation_data
    st.session_state.processing_complete = True
    
    st.success("All synthetic data processed successfully!")
    return all_extracted_data, all_evaluation_data

# -------------------------------------------------------------------
# Formatting Functions
# -------------------------------------------------------------------

def format_stage_1_output(extracted_data):
    """
    Formats the extracted data into a structured string for stage 1 output.

    This function organizes the extracted fields and their explanations into a readable format.

    Parameters:
    - extracted_data (dict): The data extracted by the AI.

    Returns:
    - str: A formatted string representing stage 1 output.
    """
    if not extracted_data:
        return ""
        
    template = """Site: "{site}"
Explanation: "{site_explanation}"

Stage: "{stage}"
Explanation: "{stage_explanation}"

Laterality: "{laterality}"
Explanation: "{laterality_explanation}"

Grade: "{grade}"
Explanation: "{grade_explanation}"

Histology: "{histology}"
Explanation: "{histology_explanation}"

Behaviour: "{behaviour}"
Explanation: "{behaviour_explanation}"
"""
    
    def get_explanation(field):
        """Helper function to generate standard explanations based on field type."""
        explanations = {
            'site': 'Based on anatomical location specified in the report.',
            'stage': 'Determined from tumor characteristics and staging information.',
            'laterality': 'As explicitly stated in the report.',
            'grade': 'Based on histological grading mentioned in the report.',
            'histology': 'According to the pathological examination results.',
            'behaviour': 'Based on the tumor behavior characteristics described.'
        }
        return explanations.get(field, 'Information extracted from the report.')
    
    return template.format(
        site=extracted_data.get("site", "UNKNOWN"),
        site_explanation=get_explanation('site'),
        stage=extracted_data.get("stage", "UNKNOWN"),
        stage_explanation=get_explanation('stage'),
        laterality=extracted_data.get("laterality", "UNKNOWN"),
        laterality_explanation=get_explanation('laterality'),
        grade=extracted_data.get("grade", "UNKNOWN"),
        grade_explanation=get_explanation('grade'),
        histology=extracted_data.get("histology", "UNKNOWN"),
        histology_explanation=get_explanation('histology'),
        behaviour=extracted_data.get("behaviour", "UNKNOWN"),
        behaviour_explanation=get_explanation('behaviour')
    )

def format_stage_2_output(evaluation_data):
    """
    Formats the evaluation data into a structured string for stage 2 output.

    This function organizes the evaluation results, including AI extraction, correct values,
    justifications, scores, and reasoning into a readable format.

    Parameters:
    - evaluation_data (dict): The evaluation results from the LLM.

    Returns:
    - str: A formatted string representing stage 2 output.
    """
    if not evaluation_data:
        return ""
    
    template = """### Review and Scoring for Pathology Report

1. **Site**:
   - **AI Extraction**: "{site_extracted}"
   - **Correct Value**: "{site_correct}"
   - **Justification**: {site_justification}
   - **Score**: {site_score}
   - **Reasoning**: {site_reasoning}

2. **Stage**:
   - **AI Extraction**: "{stage_extracted}"
   - **Correct Value**: "{stage_correct}"
   - **Justification**: {stage_justification}
   - **Score**: {stage_score}
   - **Reasoning**: {stage_reasoning}

3. **Laterality**:
   - **AI Extraction**: "{laterality_extracted}"
   - **Correct Value**: "{laterality_correct}"
   - **Justification**: {laterality_justification}
   - **Score**: {laterality_score}
   - **Reasoning**: {laterality_reasoning}

4. **Grade**:
   - **AI Extraction**: "{grade_extracted}"
   - **Correct Value**: "{grade_correct}"
   - **Justification**: {grade_justification}
   - **Score**: {grade_score}
   - **Reasoning**: {grade_reasoning}

5. **Histology**:
   - **AI Extraction**: "{histology_extracted}"
   - **Correct Value**: "{histology_correct}"
   - **Justification**: {histology_justification}
   - **Score**: {histology_score}
   - **Reasoning**: {histology_reasoning}

6. **Behaviour**:
   - **AI Extraction**: "{behaviour_extracted}"
   - **Correct Value**: "{behaviour_correct}"
   - **Justification**: {behaviour_justification}
   - **Score**: {behaviour_score}
   - **Reasoning**: {behaviour_reasoning}

### Summary

All categories have been reviewed and scored with appropriate justifications."""

    return template.format(
        site_extracted=get_evaluation_field(evaluation_data, "site", "extracted"),
        site_correct=get_evaluation_field(evaluation_data, "site", "correct"),
        site_justification=get_evaluation_field(evaluation_data, "site", "justification"),
        site_score=get_evaluation_field(evaluation_data, "site", "score"),
        site_reasoning="The extraction was compared against the provided ground truth.",
        
        stage_extracted=get_evaluation_field(evaluation_data, "stage", "extracted"),
        stage_correct=get_evaluation_field(evaluation_data, "stage", "correct"),
        stage_justification=get_evaluation_field(evaluation_data, "stage", "justification"),
        stage_score=get_evaluation_field(evaluation_data, "stage", "score"),
        stage_reasoning="Based on TNM classification and staging criteria.",
        
        laterality_extracted=get_evaluation_field(evaluation_data, "laterality", "extracted"),
        laterality_correct=get_evaluation_field(evaluation_data, "laterality", "correct"),
        laterality_justification=get_evaluation_field(evaluation_data, "laterality", "justification"),
        laterality_score=get_evaluation_field(evaluation_data, "laterality", "score"),
        laterality_reasoning="Verified against explicit laterality mentions in the report.",
        
        grade_extracted=get_evaluation_field(evaluation_data, "grade", "extracted"),
        grade_correct=get_evaluation_field(evaluation_data, "grade", "correct"),
        grade_justification=get_evaluation_field(evaluation_data, "grade", "justification"),
        grade_score=get_evaluation_field(evaluation_data, "grade", "score"),
        grade_reasoning="Compared with histological grading in the report.",
        
        histology_extracted=get_evaluation_field(evaluation_data, "histology", "extracted"),
        histology_correct=get_evaluation_field(evaluation_data, "histology", "correct"),
        histology_justification=get_evaluation_field(evaluation_data, "histology", "justification"),
        histology_score=get_evaluation_field(evaluation_data, "histology", "score"),
        histology_reasoning="Validated against pathological findings.",
        
        behaviour_extracted=get_evaluation_field(evaluation_data, "behaviour", "extracted"),
        behaviour_correct=get_evaluation_field(evaluation_data, "behaviour", "correct"),
        behaviour_justification=get_evaluation_field(evaluation_data, "behaviour", "justification"),
        behaviour_score=get_evaluation_field(evaluation_data, "behaviour", "score"),
        behaviour_reasoning="Assessed based on described tumor characteristics."
    )

def format_stage_3_output(extracted_data):
    """
    Formats the extracted data into a JSON string for stage 3 output.

    This function ensures that all score fields are safely converted to floats, with default values
    provided if conversion fails.

    Parameters:
    - extracted_data (dict): The data extracted by the AI.

    Returns:
    - str: A JSON-formatted string representing stage 3 output.
    """
    if not extracted_data:
        return ""
    
    def safe_float_convert(value, default=1.0):
        """
        Safely converts a value to float.

        If conversion fails, returns the default value.

        Parameters:
        - value: The value to convert.
        - default (float): The default value to return if conversion fails.

        Returns:
        - float: The converted float value or the default.
        """
        if isinstance(value, (int, float)):
            return float(value)
        if isinstance(value, str):
            try:
                return float(value)
            except ValueError:
                return default
        return default
    
    output_data = {
        "site": extracted_data.get("site", "UNKNOWN"),
        "site_score": safe_float_convert(extracted_data.get("site_score")),
        "stage": extracted_data.get("stage", "UNKNOWN"),
        "stage_score": safe_float_convert(extracted_data.get("stage_score")),
        "laterality": extracted_data.get("laterality", "UNKNOWN"),
        "laterality_score": safe_float_convert(extracted_data.get("laterality_score")),
        "grade": extracted_data.get("grade", "UNKNOWN"),
        "grade_score": safe_float_convert(extracted_data.get("grade_score")),
        "histology": extracted_data.get("histology", "UNKNOWN"),
        "histology_score": safe_float_convert(extracted_data.get("histology_score")),
        "behaviour": extracted_data.get("behaviour", "UNKNOWN"),
        "behaviour_score": safe_float_convert(extracted_data.get("behaviour_score"))
    }
    
    return json.dumps(output_data, indent=3)

def get_evaluation_field(evaluation_data, field, subfield):
    """
    Safely retrieves a specific subfield from the evaluation data.

    Parameters:
    - evaluation_data (dict): The evaluation data dictionary.
    - field (str): The field name to retrieve (e.g., 'site', 'stage').
    - subfield (str): The subfield within the field (e.g., 'extracted', 'correct').

    Returns:
    - str or float: The value of the subfield, formatted appropriately.
    """
    try:
        field_data = evaluation_data.get(f"{field}_evaluation", {}) or {}
        value = field_data.get(subfield, "UNKNOWN")
        if subfield == "score":
            return float(value) if isinstance(value, (int, float)) else (float(value) if isinstance(value, str) and value.replace('.', '').isdigit() else 1)
        return value
    except (TypeError, ValueError):
        return "UNKNOWN" if subfield != "score" else 1

# -------------------------------------------------------------------
# Synthetic Data Example
# -------------------------------------------------------------------

# Example synthetic data to demonstrate the application's functionality.
# In a real-world scenario, this data would come from actual clinical notes.
synthetic_clinical_notes = [
    {
        "clinical_note": """
        Date: March 28, 2024

        Patient: Jane Doe, 50 years old
        MRN: 12345678

        Chief Complaint: Lump in the right breast.

        History of Present Illness: The patient noticed a lump in the upper outer quadrant of her right breast two weeks ago. She reports tenderness but no discharge. No history of breast cancer in the family.

        Physical Examination:
        Breast: Palpable lump in the upper outer quadrant of the right breast, approximately 2 cm in diameter.

        Assessment/Plan:
        - Mammogram and ultrasound of the right breast.
        - Biopsy if imaging findings are concerning.
        - Follow up in one week.
        - Patient is stage 0 and grade is G2.
        """,
        "ground_truth": {
            "mrn": "12345678",
            "site": "UPPER OUTER QUADRANT",
            "stage": "0",
            "laterality": "RIGHT",
            "grade": "G2"
        }
    },
    {
        "clinical_note": """
        Date: March 30, 2024

        Patient: John Smith, 60 years old
        MRN: 98765432

        Chief Complaint: Mass in the left breast.

        History of Present Illness: The patient discovered a mass in the lower inner quadrant of his left breast. No pain or tenderness noted. Family history of breast cancer in his sister.

        Physical Examination:
        Breast: Fixed mass in the lower inner quadrant of the left breast, approximately 3 cm in diameter.

        Assessment/Plan:
        - Core needle biopsy.
        - Referral to oncology.
        - Patient is stage IIA and grade is G3
        """,
        "ground_truth": {
            "mrn": "98765432",
            "site": "LOWER INNER QUADRANT",
            "stage": "IIA",
            "laterality": "LEFT",
            "grade": "G3"
        }
    },
    {
        "clinical_note": """
        Pathology Report Viewer

        MRN: 12332178

        Final Output Ground Truth

        + Site: UPPER OUTER QUADRANT

        ‘\nlite": “UPPER OUTER QUADRANT, + Stage:0
        site score": 1) + Lateraity: RIGHT

        + Grade: G2

        “grade”: "62"
        "grade_score

        athology Report Viewer

        + Site: UPPER OUTER QUADRANT Explanation: The report mentions “ductal carcinoma in situ measuring 0.2 cm in greatest dimension’ and specifies its location as “located in the upper outer quadrant at 10 o'clock position*
        + Stage: 2A Explanation: The tumor measures 2.2 cm, which corresponds to pT2. There is no mention of lymph node involvement or metastasis, so it is assumed to be pN0M0, resulting in a stage of 2A
        + Laterality: RIGHT Explanation: The report explicitly mentions "RIGHT BREAST” multiple times throughout the document.

        + Grade: G3 Explanation: Although not directly stated, the report describes the tumor as “ductal carcinoma in-situ with focal mucin production, intermediate nuclear grade without necrosis and with calcifications*
        Intermediate grade typically corresponds to G2, but since it is described with mucin production, it is considered G3'
        """,
        "ground_truth": {
            "mrn": "12332178",
            "site": "UPPER OUTER QUADRANT",
            "stage": "2A",
            "laterality": "RIGHT",
            "grade": "G3"
        }
    }
]

# -------------------------------------------------------------------
# Display and Processing Functions
# -------------------------------------------------------------------

def display_batch_results():
    """
    Displays all processed synthetic data results in an organized and expandable format.

    For each example, this function shows the clinical note, ground truth data,
    extracted data, and evaluation results side by side. It also provides a summary
    of evaluation scores.
    """
    if not st.session_state.get("processing_complete"):
        return
        
    st.markdown("### Processed Results")
    
    for i, (note, extracted, evaluated) in enumerate(zip(
        synthetic_clinical_notes,
        st.session_state.all_extracted_data,
        st.session_state.all_evaluation_data
    )):
        mrn = note['ground_truth'].get('mrn', 'N/A')
        with st.expander(f"Example {i + 1} - MRN: {mrn}", expanded=True):
            # Display the clinical note
            st.markdown("**Clinical Note:**")
            st.text(note['clinical_note'])
            
            st.markdown("---")
            
            # Display ground truth, extracted data, and evaluation in three columns
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.markdown("**Ground Truth**")
                st.json(note['ground_truth'])
                
            with col2:
                st.markdown("**Extracted Data**")
                if extracted:
                    st.json(extracted)
                else:
                    st.error("Extraction failed")
                    
            with col3:
                st.markdown("**Evaluation**")
                if evaluated:
                    st.json(evaluated)
                else:
                    st.error("Evaluation failed")
            
            # Display evaluation scores if available
            if evaluated:
                st.markdown("---")
                st.markdown("**Evaluation Scores:**")
                scores_table = []
                for field in ["mrn", "site", "stage", "laterality", "grade"]:
                    eval_key = f"{field}_evaluation"
                    if eval_key in evaluated:
                        eval_entry = evaluated[eval_key]
                        scores_table.append({
                            "Field": field.capitalize(),
                            "Score": eval_entry.get("score", 0),
                            "Justification": eval_entry.get("justification", "")
                        })
                st.table(pd.DataFrame(scores_table))

def display_extraction_details(extracted_data):
    """
    Displays the extracted fields in a structured and readable format.

    Parameters:
    - extracted_data (dict): The data extracted by the AI from the clinical note.
    """
    if not extracted_data:
        st.write("No AI extraction data available.")
        return
        
    extraction_details = {
        "MRN": extracted_data.get("mrn", ""),
        "Site": extracted_data.get("site", ""),
        "Stage": extracted_data.get("stage", ""),
        "Laterality": extracted_data.get("laterality", ""),
        "Grade": extracted_data.get("grade", ""),
        "Histology": extracted_data.get("histology", ""),
        "Behaviour": extracted_data.get("behaviour", "")
    }
    
    # Display each field in a two-column layout for clarity
    st.markdown("### Extracted Fields")
    for field, value in extraction_details.items():
        col1, col2 = st.columns([1, 3])
        with col1:
            st.markdown(f"**{field}:**")
        with col2:
            st.write(value if value else "Not available")

def display_evaluation_details(evaluation_data):
    """
    Displays the evaluation results in a structured table.

    Parameters:
    - evaluation_data (dict): The evaluation results comparing extracted data against ground truth.
    """
    if not evaluation_data:
        st.write("No AI evaluation data available.")
        return
        
    st.markdown("### Evaluation Results")
    evaluation_table = []
    
    # Iterate through each field to compile evaluation data
    for field in ["mrn", "site", "stage", "laterality", "grade", "histology", "behaviour"]:
        eval_key = f"{field}_evaluation"
        if eval_key in evaluation_data:
            eval_entry = evaluation_data[eval_key]
            evaluation_table.append({
                "Field": field.capitalize(),
                "Extracted": eval_entry.get("extracted", ""),
                "Correct": eval_entry.get("correct", ""),
                "Score": eval_entry.get("score", 0),
                "Justification": eval_entry.get("justification", "")
            })
    
    if evaluation_table:
        st.table(pd.DataFrame(evaluation_table))
    else:
        st.write("No evaluation details available")

def process_dataframe_for_display(records):
    """
    Processes MongoDB records into a Pandas DataFrame suitable for display.

    This function handles type conversions and ensures that all data is formatted
    correctly for visualization within Streamlit.

    Parameters:
    - records (list): A list of MongoDB record dictionaries.

    Returns:
    - pandas.DataFrame: A DataFrame containing processed record summaries.
    """
    # Create record summaries with proper type handling
    processed_records = []
    for record in records:
        try:
            stage_3_data = json.loads(record.get('stage_3_output', '{}'))
        except json.JSONDecodeError:
            stage_3_data = {}
        
        # Function to format score fields
        def format_score(score):
            if score is None or score == 'N/A' or score == 'UNKNOWN':
                return 'N/A'
            try:
                return f"{float(score):.2f}"
            except (ValueError, TypeError):
                return 'N/A'
        
        record_summary = {
            'Record ID': str(record.get('_id', 'N/A')),
            'File Name': str(record.get('pdf_file_name', 'N/A')),
            'Organ': str(record.get('organ', 'N/A')),
            'Site': str(stage_3_data.get('site', 'N/A')),
            'Stage': str(stage_3_data.get('stage', 'N/A')),
            'Laterality': str(stage_3_data.get('laterality', 'N/A')),
            'Grade': str(stage_3_data.get('grade', 'N/A')),
            'Site Score': format_score(stage_3_data.get('site_score')),
            'Stage Score': format_score(stage_3_data.get('stage_score')),
            'Laterality Score': format_score(stage_3_data.get('laterality_score')),
            'Grade Score': format_score(stage_3_data.get('grade_score'))
        }
        processed_records.append(record_summary)
    
    # Create DataFrame with explicit string data types to ensure compatibility
    df = pd.DataFrame(processed_records).astype(str)
    return df

def display_database_records(records):
    """
    Displays an overview of all records stored in MongoDB.

    Provides a DataFrame view of key fields and allows users to select individual records
    for detailed inspection. Also offers export and deletion options.

    Parameters:
    - records (list): A list of MongoDB record dictionaries.
    """
    if not records:
        st.write("No records available to display.")
        return

    st.subheader("Database Records Overview")
    
    # Process records into DataFrame with proper type handling
    df = process_dataframe_for_display(records)
    
    # Display the DataFrame using Streamlit's dataframe component
    st.dataframe(df, use_container_width=True)
    
    # Detailed View Section
    st.markdown("### Detailed Record View")
    st.markdown("Select a record to view all details including clinical notes and evaluation:")
    
    record_ids = df['Record ID'].tolist()
    selected_id = st.selectbox(
        "Select Record ID to view details",
        options=record_ids,
        key="detailed_view_id"
    )
    
    if selected_id:
        selected_record = next((r for r in records if str(r.get('_id')) == selected_id), None)
        if selected_record:
            display_detailed_record(selected_record)

def display_detailed_record(record):
    """
    Displays detailed information for a single MongoDB record.

    Shows clinical notes, extraction results, evaluation results, and scores.

    Parameters:
    - record (dict): The MongoDB record dictionary to display.
    """
    with st.expander("View Complete Record Details", expanded=True):
        # Display Clinical Note
        st.markdown("**Clinical Note**")
        st.text(record.get('clinical_note', 'No clinical note available'))
        
        st.markdown("---")
        
        # Display Stage 1 Output (Extraction) and Stage 2 Output (Evaluation) side by side
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("**Stage 1 Output (Extraction)**")
            st.markdown(record.get('stage_1_output', 'No extraction data available'))
        
        with col2:
            st.markdown("**Stage 2 Output (Evaluation)**")
            st.markdown(record.get('stage_2_output', 'No evaluation data available'))
        
        # Display Stage 3 Output (Final Scores)
        st.markdown("---")
        st.markdown("**Stage 3 Output (Final Scores)**")
        try:
            stage_3_data = json.loads(record.get('stage_3_output', '{}'))
            if stage_3_data:
                # Create a table for scores
                scores_data = []
                for field in ['site', 'stage', 'laterality', 'grade', 'histology', 'behaviour']:
                    scores_data.append({
                        'Field': field.capitalize(),
                        'Value': stage_3_data.get(field, 'N/A'),
                        'Score': stage_3_data.get(f'{field}_score', 'N/A')
                    })
                st.table(pd.DataFrame(scores_data))
            else:
                st.write("No score data available")
        except json.JSONDecodeError:
            st.write("Error parsing score data")

def export_records_to_csv(records):
    """
    Exports MongoDB records to a CSV format.

    Converts the records into a Pandas DataFrame and then to a CSV string.

    Parameters:
    - records (list): A list of MongoDB record dictionaries.

    Returns:
    - str: A CSV-formatted string of the records.
    """
    df = process_dataframe_for_display(records)
    
    # Convert to CSV using StringIO buffer
    csv_buffer = StringIO()
    df.to_csv(csv_buffer, index=False)
    return csv_buffer.getvalue()

def display_main_content():
    """
    Displays the main content area when data is loaded.

    This includes displaying selected records, database records overview,
    and export/delete options.
    """
    if st.session_state.selected_mrn:
        display_selected_record()
    
    # Database Records Section
    st.markdown("---")
    st.header("Database Records")
    
    # Refresh database button to reload data from MongoDB
    if st.button("Refresh Database"):
        with st.spinner("Refreshing data..."):
            load_data_into_session_state()
            st.rerun()

    # Display records from the database
    display_database_records(st.session_state.records)
    
    # Export and Delete Options
    display_export_delete_options()

def display_selected_record():
    """
    Displays details for the selected MRN (Medical Record Number).

    Filters records by the selected MRN and allows navigation between multiple records if available.
    """
    # Filter records by selected MRN
    filtered_records = [r for r in st.session_state.records 
                       if r.get("ground_truth", {}).get("mrn") == st.session_state.selected_mrn]

    if not filtered_records:
        st.write("No records found for this MRN.")
        return

    # Setup navigation buttons if multiple records exist for the MRN
    setup_record_navigation(filtered_records)
    
    # Display current record based on navigation index
    current_record = filtered_records[st.session_state.report_index]
    display_record_details(current_record)

def setup_record_navigation(filtered_records):
    """
    Sets up navigation buttons (Previous/Next) for navigating through multiple reports.

    Parameters:
    - filtered_records (list): A list of records filtered by MRN.
    """
    if "report_index" not in st.session_state:
        st.session_state.report_index = 0

    col_nav1, col_nav2 = st.columns([1,1])
    with col_nav1:
        if st.button("Previous") and st.session_state.report_index > 0:
            st.session_state.report_index -= 1
    with col_nav2:
        if st.button("Next") and st.session_state.report_index < len(filtered_records)-1:
            st.session_state.report_index += 1

    # Reset navigation if MRN changes
    if st.session_state.get("current_mrn") != st.session_state.selected_mrn:
        st.session_state.report_index = 0
        st.session_state.current_mrn = st.session_state.selected_mrn

def display_record_details(current_record):
    """
    Displays detailed information for the current record.

    Includes extracted data, ground truth, pathology report, and AI evaluation results.

    Parameters:
    - current_record (dict): The MongoDB record dictionary to display.
    """
    # Output and Ground Truth columns
    col_left, col_right = st.columns([1,1])
    
    with col_left:
        st.subheader("Final Output")
        if "extracted_data" in current_record and current_record["extracted_data"]:
            st.json(current_record["extracted_data"])
        else:
            st.write("No extracted data available.")

    with col_right:
        st.subheader("Ground Truth")
        if "ground_truth" in current_record and current_record["ground_truth"]:
            st.json(current_record["ground_truth"])
        else:
            st.write("No ground truth available.")

    # Pathology Report Section
    st.markdown("---")
    st.subheader("Pathology Report")
    st.write(current_record.get("clinical_note", "No clinical note available."))

    # Batch Processing Section
    st.markdown("---")
    add_batch_processing_section()

    # AI Extraction and Evaluation
    display_ai_results(current_record)

def display_ai_results(current_record):
    """
    Displays AI extraction and evaluation results for a given record.

    Parameters:
    - current_record (dict): The MongoDB record dictionary containing AI results.
    """
    st.markdown("---")
    
    # AI Extraction Details
    st.subheader("AI Extraction")
    extracted_data = get_extraction_data(current_record)
    display_extraction_details(extracted_data)

    # AI Evaluation Details
    st.subheader("AI Evaluation")
    evaluation_data = get_evaluation_data(current_record)
    display_evaluation_details(evaluation_data)

def get_extraction_data(current_record):
    """
    Retrieves the extracted data from the session state or the record itself.

    Parameters:
    - current_record (dict): The MongoDB record dictionary.

    Returns:
    - dict or None: The extracted data dictionary.
    """
    if st.session_state.get("all_extracted_data"):
        return st.session_state.all_extracted_data[st.session_state.report_index]
    return current_record.get("extracted_data")

def get_evaluation_data(current_record):
    """
    Retrieves the evaluation data from the session state or the record itself.

    Parameters:
    - current_record (dict): The MongoDB record dictionary.

    Returns:
    - dict or None: The evaluation data dictionary.
    """
    if st.session_state.get("all_evaluation_data"):
        return st.session_state.all_evaluation_data[st.session_state.report_index]
    return current_record.get("evaluation")

def display_export_delete_options():
    """
    Displays options for exporting records to CSV and deleting records from the database.

    Includes buttons for exporting data and deleting all records, with appropriate warnings and confirmations.
    """
    # Export to CSV Section
    st.subheader("Export Records")
    if st.button("Export to CSV"):
        csv_data = export_records_to_csv(st.session_state.records)
        st.download_button(
            label="Download CSV",
            data=csv_data,
            file_name="medical_data.csv",
            mime="text/csv"
        )

    # Delete All Records Section
    st.subheader("Delete All Records")
    if st.button("Delete All Records (Warning: Irreversible!)"):
        handle_delete_confirmation()

def handle_delete_confirmation():
    """
    Handles the confirmation process for deleting all records from MongoDB.

    Requires the user to confirm deletion by clicking the button twice.
    """
    if st.session_state.delete_confirmed:
        with st.spinner("Deleting records..."):
            deleted_count = delete_all_records_from_mongodb()
        st.success(f"Deleted {deleted_count} records from the database.")
        st.session_state.records = []
        st.session_state.data_loaded = False
        st.session_state.delete_confirmed = False
        st.rerun()
    else:
        st.session_state.delete_confirmed = True
        st.warning("Please confirm the deletion by clicking the button again.")
        st.stop()

# -------------------------------------------------------------------
# Data Retrieval Functions
# -------------------------------------------------------------------

def get_all_records():
    """
    Retrieves all records from MongoDB.

    Fetches all documents from the specified collection and converts the ObjectId to a string.

    Returns:
    - list: A list of MongoDB record dictionaries.
    """
    try:
        client = MongoClient(MONGO_URI)
        db = client[DATABASE_NAME]
        collection = db[COLLECTION_NAME]
        docs = list(collection.find())  # Convert cursor to list
        
        # Convert the _id field to string for consistency
        for doc in docs:
            doc['_id'] = str(doc['_id'])
            
        return docs
    except Exception as e:
        st.error(f"Error fetching records from MongoDB: {e}")
        return []

def load_data_into_session_state():
    """
    Loads data from MongoDB into Streamlit's session state.

    This function fetches all records and stores them in the session state for use throughout the application.
    """
    records = get_all_records()
    if records:
        st.session_state.records = records
        st.session_state.data_loaded = True
        st.success(f"Successfully loaded {len(records)} record(s) from database!")
    else:
        st.warning("No records found in the database.")
        st.session_state.data_loaded = False

# -------------------------------------------------------------------
# Cleanup and Maintenance Functions
# -------------------------------------------------------------------

def add_cleanup_option():
    """
    Adds a cleanup option to the Streamlit sidebar for removing invalid records from MongoDB.

    Includes a button that, when clicked, will delete all records that do not contain valid data.
    """
    st.sidebar.markdown("---")
    st.sidebar.subheader("Database Cleanup")
    if st.sidebar.button("Remove Invalid Records"):
        with st.spinner("Removing invalid records..."):
            removed_count = clear_invalid_records()
            if removed_count > 0:
                st.sidebar.success(f"Removed {removed_count} invalid record(s)")
                # Refresh the data after cleanup
                load_data_into_session_state()
                st.rerun()
            else:
                st.sidebar.info("No invalid records found")

# -------------------------------------------------------------------
# Sidebar Configuration
# -------------------------------------------------------------------

def setup_sidebar():
    """
    Configures and displays sidebar elements in the Streamlit application.

    Includes options for testing MongoDB connection, loading data, filtering by MRN,
    and performing database cleanup.
    """
    st.sidebar.header("MongoDB Connection")
    
    # Test connection button
    if st.sidebar.button("Test Connection"):
        if test_mongodb_connection():
            st.sidebar.success("MongoDB connection successful!")
        else:
            st.sidebar.error("MongoDB connection failed. Check your URI.")
    
    # Load data button
    if st.sidebar.button("Load Data"):
        with st.spinner("Loading data..."):
            load_data_into_session_state()
    
    # Only show filter options if data is loaded
    if st.session_state.data_loaded and st.session_state.records:
        setup_mrn_filters()
    
    # Add cleanup option
    add_cleanup_option()

def setup_mrn_filters():
    """
    Sets up Medical Record Number (MRN) filtering options in the sidebar.

    Allows users to search and select specific MRNs to view corresponding records.
    """
    # Extract unique MRNs from the records
    mrn_list = [r.get("ground_truth", {}).get("mrn") for r in st.session_state.records 
                if r.get("ground_truth", {}).get("mrn")]
    mrn_list = sorted(list(set(mrn_list)))

    # MRN search and filter input
    st.sidebar.header("Filter Options")
    search_mrn = st.sidebar.text_input("Search MRN...", 
                                      value="", 
                                      help="Type a partial MRN to filter results")
    
    # Filter MRNs based on user input
    filtered_mrn_list = [mrn for mrn in mrn_list if search_mrn in str(mrn)] if search_mrn else mrn_list

    if not filtered_mrn_list:
        st.sidebar.warning("No MRNs match your search.")
        st.session_state.selected_mrn = None
    else:
        st.session_state.selected_mrn = st.sidebar.selectbox("Select MRN", filtered_mrn_list)

def test_mongodb_connection():
    """
    Tests the connection to MongoDB.

    Attempts to connect to MongoDB using the provided URI and returns the result.

    Returns:
    - bool: True if the connection is successful, False otherwise.
    """
    try:
        client = MongoClient(MONGO_URI, serverSelectionTimeoutMS=2000)  # Shorter timeout for testing
        client.server_info()  # Force a connection attempt
        return True
    except pymongo.errors.ConnectionFailure:
        return False

# -------------------------------------------------------------------
# Record Navigation Functions
# -------------------------------------------------------------------

def setup_record_navigation(filtered_records):
    """
    Sets up navigation buttons for navigating through multiple reports for a selected MRN.

    Parameters:
    - filtered_records (list): A list of records filtered by MRN.
    """
    if "report_index" not in st.session_state:
        st.session_state.report_index = 0

    col_nav1, col_nav2 = st.columns([1,1])
    with col_nav1:
        if st.button("Previous") and st.session_state.report_index > 0:
            st.session_state.report_index -= 1
    with col_nav2:
        if st.button("Next") and st.session_state.report_index < len(filtered_records)-1:
            st.session_state.report_index += 1

    # Reset navigation index if the selected MRN changes
    if st.session_state.get("current_mrn") != st.session_state.selected_mrn:
        st.session_state.report_index = 0
        st.session_state.current_mrn = st.session_state.selected_mrn

# -------------------------------------------------------------------
# Batch Processing Section
# -------------------------------------------------------------------

def add_batch_processing_section():
    """
    Adds the batch processing section to the Streamlit UI.

    This section allows users to process all synthetic data examples, review the results,
    and store them in the database.
    """
    st.markdown("---")
    st.header("Batch Processing of Synthetic Data")
    
    # Add description of the batch processing steps
    st.markdown("""
    Process all synthetic data examples at once and review the results before storing in the database.
    1. Click "Process All Examples" to run the extraction and evaluation
    2. Review the results for each example
    3. Click "Store All Results in Database" to save if satisfied
    """)
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("Process All Examples", key="process_all"):
            with st.spinner("Processing all examples..."):
                process_all_synthetic_data()
                
    with col2:
        if st.session_state.get("processing_complete"):
            if st.button("Store All Results in Database", key="store_all"):
                with st.spinner("Storing results in database..."):
                    success = store_batch_in_mongodb()
                    if success:
                        st.session_state.data_loaded = True  # Ensure data is marked as loaded
                        time.sleep(1)  # Brief pause to show success message
                        st.rerun()  # Force a rerun to refresh the entire app
    
    # Display results if processing is complete
    if st.session_state.get("processing_complete"):
        display_batch_results()

# -------------------------------------------------------------------
# Main Content Display Functions
# -------------------------------------------------------------------

def display_selected_record():
    """
    Displays details for the selected Medical Record Number (MRN).

    Filters records by the selected MRN and allows navigation through multiple reports if available.
    """
    # Filter records by selected MRN
    filtered_records = [r for r in st.session_state.records 
                       if r.get("ground_truth", {}).get("mrn") == st.session_state.selected_mrn]

    if not filtered_records:
        st.write("No records found for this MRN.")
        return

    # Setup navigation buttons for multiple reports
    setup_record_navigation(filtered_records)
    
    # Display current record based on navigation index
    current_record = filtered_records[st.session_state.report_index]
    display_record_details(current_record)

def display_record_details(current_record):
    """
    Displays detailed information for a specific record.

    Shows extracted data, ground truth, clinical notes, and AI evaluation results.

    Parameters:
    - current_record (dict): The MongoDB record dictionary to display.
    """
    # Output and Ground Truth columns for clarity
    col_left, col_right = st.columns([1,1])
    
    with col_left:
        st.subheader("Final Output")
        if "extracted_data" in current_record and current_record["extracted_data"]:
            st.json(current_record["extracted_data"])
        else:
            st.write("No extracted data available.")

    with col_right:
        st.subheader("Ground Truth")
        if "ground_truth" in current_record and current_record["ground_truth"]:
            st.json(current_record["ground_truth"])
        else:
            st.write("No ground truth available.")

    # Pathology Report Section
    st.markdown("---")
    st.subheader("Pathology Report")
    st.write(current_record.get("clinical_note", "No clinical note available."))

    # Batch Processing Section
    st.markdown("---")
    add_batch_processing_section()

    # AI Extraction and Evaluation
    display_ai_results(current_record)

def display_ai_results(current_record):
    """
    Displays AI extraction and evaluation results for a given record.

    Parameters:
    - current_record (dict): The MongoDB record dictionary containing AI results.
    """
    st.markdown("---")
    
    # AI Extraction Details
    st.subheader("AI Extraction")
    extracted_data = get_extraction_data(current_record)
    display_extraction_details(extracted_data)

    # AI Evaluation Details
    st.subheader("AI Evaluation")
    evaluation_data = get_evaluation_data(current_record)
    display_evaluation_details(evaluation_data)

# -------------------------------------------------------------------
# Application Entry Point
# -------------------------------------------------------------------

def main():
    """
    The main function that orchestrates the Streamlit application.

    Sets up the page configuration, initializes session state variables,
    configures the sidebar, and displays the main content based on data availability.
    """
    st.set_page_config(page_title="Pathology Report Viewer", layout="wide")
    st.title("Pathology Report Viewer")

    # Initialize session state variables for maintaining state across interactions
    if "data_loaded" not in st.session_state:
        st.session_state.data_loaded = False
    if "records" not in st.session_state:
        st.session_state.records = []
    if "processing_complete" not in st.session_state:
        st.session_state.processing_complete = False
    if "delete_confirmed" not in st.session_state:
        st.session_state.delete_confirmed = False
    if "selected_mrn" not in st.session_state:
        st.session_state.selected_mrn = None
    if "report_index" not in st.session_state:
        st.session_state.report_index = 0
    if "current_mrn" not in st.session_state:
        st.session_state.current_mrn = None

    # Sidebar Setup
    setup_sidebar()

    # Main Content Area
    if st.session_state.data_loaded and st.session_state.records:
        display_main_content()
    else:
        handle_empty_database()

def handle_empty_database():
    """
    Handles the scenario when the MongoDB database is empty.

    Provides an option to populate the database with synthetic data for demonstration purposes.
    """
    st.warning("No records found in the database. You can populate it with synthetic data.")
    if st.button("Populate Database with Synthetic Data"):
        with st.spinner("Processing and inserting synthetic data..."):
            outputs = process_clinical_notes(synthetic_clinical_notes)
        st.success("Synthetic data inserted successfully!")
        load_data_into_session_state()

# -------------------------------------------------------------------
# Detailed Record View Function
# -------------------------------------------------------------------

def display_detailed_record(record):
    """
    Displays a detailed view of a single record, including all stages of processing.

    Parameters:
    - record (dict): The MongoDB record dictionary to display.
    """
    with st.expander("View Complete Record Details", expanded=True):
        # Display Clinical Note
        st.markdown("**Clinical Note**")
        st.text(record.get('clinical_note', 'No clinical note available'))
        
        st.markdown("---")
        
        # Display Stage 1 Output (Extraction) and Stage 2 Output (Evaluation) side by side
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("**Stage 1 Output (Extraction)**")
            st.markdown(record.get('stage_1_output', 'No extraction data available'))
        
        with col2:
            st.markdown("**Stage 2 Output (Evaluation)**")
            st.markdown(record.get('stage_2_output', 'No evaluation data available'))
        
        # Display Stage 3 Output (Final Scores)
        st.markdown("---")
        st.markdown("**Stage 3 Output (Final Scores)**")
        try:
            stage_3_data = json.loads(record.get('stage_3_output', '{}'))
            if stage_3_data:
                # Create a table for scores
                scores_data = []
                for field in ['site', 'stage', 'laterality', 'grade', 'histology', 'behaviour']:
                    scores_data.append({
                        'Field': field.capitalize(),
                        'Value': stage_3_data.get(field, 'N/A'),
                        'Score': stage_3_data.get(f'{field}_score', 'N/A')
                    })
                st.table(pd.DataFrame(scores_data))
            else:
                st.write("No score data available")
        except json.JSONDecodeError:
            st.write("Error parsing score data")

# -------------------------------------------------------------------
# Application Initialization
# -------------------------------------------------------------------

# Execute the main function when the script is run
if __name__ == '__main__':
    main()
